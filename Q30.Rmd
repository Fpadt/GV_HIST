---
title: "Legacy Sales - Vision Express UK"
author: "F.J.Padt"
date: "`r Sys.Date()`"
output: 
   pdf_document:
    toc:             true
    toc_depth:       2
    number_sections: true
    fig_caption:     true
    fig_crop:        true
    highlight:       tango    
---

\newpage
![Logo](http://www.grandvision.com/img/logoGV.png) 

```{r RSetup, echo=FALSE, eval=TRUE, cache=FALSE, results='hide'}

rm(list=ls())
gc()

source('../QAR/00_RProj/00_Global/iSynGeneral.R')

# Data Settings
fECHO    <- FALSE
fEVAL    <- TRUE
fRESULTS <- 'hide' 

# SAP systems to use
pECC_SYST <- "RP1"
pECC_CLNT <- "300"
pBI_SYST  <- "BP1" 
pBI_CLNT  <- "300"
pLGCINDC  <- "C"

# Data Settings
pOPCO     <- "VEUK"
pROWS     <- -1L
pSMALL    <- 1000
pEXP      <- FALSE
# pPART     <- "2014H1"
pPath     <- "./60_Results"  
pXLSX     <- paste0(pOPCO, "_SALES") 
# pFILE     <- paste(  pOPCO        ,      pBI_SYST,      pPART, sep = "_") 
pEXPORT   <- paste0("POS_HISTORY" , ".csv") 

# Open Excel for storing results
if(file.exists(paste0(pPath, "/", pXLSX, ".xlsx")) == TRUE){
   file.remove(paste0(pPath, "/", pXLSX, ".xlsx"))
}

fWriteToSheet(data.frame(ECCSYST = pECC_SYST, 
                         ECCCLNT = pECC_CLNT,
                         BI_SYST = pBI_SYST ,
                         BI_CLNT = pBI_CLNT), 
              pPath, pXLSX, "PARAM", pAppend = FALSE )

```

```{r SplitVBRP, echo=FALSE, eval=FALSE, results='hide'}
# dtVBRP <- fread(file.path(".", "RAW_DATA", "VBRP_TRX_Q30.txt"), 
#                 sep=";", nrows = pROWS)
# setkey(dtVBRP, "VBELN")
# 
# dtVBRPL <- fread(file.path(".", "RAW_DATA", "VBRP_TRX_L30.txt"), 
#                 sep=";", nrows = pROWS)
# setkey(dtVBRPL, "VBELN")
# 
# dtVBRP <- rbind(dtVBRP, dtVBRPL)
# rm(dtVBRPL)

# l_months <- sort(unique(substr(dtVBRP$FBUDA, 1, 6)))
# dtMonths <- dtVBRP[, .N, by=.(substr(dtVBRP$FBUDA, 1, 6))]

# Split teh data in 3 files due to memeory constraints
# write.table(dtVBRP[substr(dtVBRP$FBUDA, 1, 6) %in% l_months[1:6]], 
#             file = file.path("c:", "FTP", 
#                              paste0("VBRP", "_", 
#                                     pBI_SYST, "_", "2014H1", ".csv")), 
#             quote = TRUE     , sep = ";", na = "", 
#             dec = ".", 
#             row.names = FALSE, col.names = TRUE, append = FALSE)
# 
# write.table(dtVBRP[substr(dtVBRP$FBUDA, 1, 6) %in% l_months[7:12]], 
#             file = file.path("c:", "FTP", 
#                              paste0("VBRP", "_", 
#                                     pBI_SYST, "_", "2014H2", ".csv")),
#             quote = TRUE     , sep = ";", na = "", dec = ".",           
#             row.names = FALSE, col.names = TRUE, append = FALSE)
# 
# write.table(dtVBRP[substr(dtVBRP$FBUDA, 1, 6) %in% l_months[13:18]], 
#             file = file.path("c:", "FTP", 
#                              paste0("VBRP", "_", 
#                                     pBI_SYST, "_", "2015H2", ".csv")),
#             quote = TRUE     , sep = ";", na = "", dec = ".",           
#             row.names = FALSE, col.names = TRUE, append = FALSE)
# rm(list=ls())
```

```{r ReadRawData, echo=fECHO, eval=fEVAL, results=fRESULTS}

# Material
dtMEAN       <- fGetSAPTable(pTable  = "MEAN", pKey = c("MATNR", "MEINH"),
                             pSystID = "RP1", pClient = "300")
dtMEAN       <- dtMEAN[, MATNR:= as.character(MATNR)]

# Site Related
dtADRC       <- fGetSAPTable(pTable  = "ADRC", 
                             pSystID = "RP1", pClient = "300")

dtT001W      <- fGetSAPTable(pTable  = "T001W", pKey = c("WERKS"),
                             pSystID = "RP1", pClient = "300")

dtPLANT      <- fGetSAPTable(pTable  = "#BI0#PPLANT",
                             pKey    = "PLANT",
                             pSystID = "BP1", pClient = "300")

dtSDP_VE    <- fread(file.path(".", "RAW_DATA", "SDP_VE.csv"), 
                sep=";")
setkey(dtSDP_VE, "WERKS")

# DataSource related
dtRSDSSEGFD  <- fGetSAPTable(pTable  = "RSDSSEGFD", 
                             pKey    = c("DATASOURCE", "POSIT"),
                             pSystID = "BP1", pClient = "300")
dtRSDSSEGFD  <- dtRSDSSEGFD[DATASOURCE == "G1_DS_PA_HIST_FLAT_FILE" ] #G0_DS_LEGACY_SLS_TD

dtRSDSSEGFDT <- fGetSAPTable(pTable  = "RSDSSEGFDT", 
                             pKey    = c("DATASOURCE", "POSIT"), 
                             pSystID = "BP1", pClient = "300")
dtRSDSSEGFDT <- dtRSDSSEGFDT[DATASOURCE == "G1_DS_PA_HIST_FLAT_FILE" & LANGU == "E" ]

# Load Legacy Billing Header and Combine
dtVBRK <- fread(file.path(".", "RAW_DATA", "ZZ_L30_VBRK.txt"), 
                sep=";", nrows = pROWS)
setkey(dtVBRK, "VBELN")
dtVBRK <- dtVBRK[FKDAT < "20150601",             # Cut-off and reduce size by removing
                 .(VBELN, FKDAT, FKART, STWAE)]  # unnecessary columns

# Only keep FKART = FP
dtVBRK <- dtVBRK[FKART == "FP" | FKART == "IV"]

# Load Legacy Billing item and Combine
dtVBRP <- fread(file.path(".", "RAW_DATA", "ZZ_L30_VBRP.txt"), 
                sep=";", nrows = pROWS)
setkey(dtVBRP, "VBELN")
dtVBRP <- dtVBRP[FBUDA < "20150601", 
                 .(VBELN, POSNR,                 # Cut-off and reduce size by removing 
                   MATNR, WERKS,                 # unnecessary columns
                   FKIMG, FBUDA,
                   NETWR, MWSBP, WAVWR, 
                   SHKZG, VRKME, ABRVW)]

#Delete records which relate to DC 
dtVBRP <- dtVBRP[!(WERKS %in% c("9900", "9999"))]

l_months <- sort(unique(substr(dtVBRP$FBUDA, 1, 6)))
dtMonths <- dtVBRP[, .N, by=.(substr(dtVBRP$FBUDA, 1, 6))]
```

# Historical Data #

The historical data for `r pOPCO` is extracted from Billing (VBRK & VBRP). 
The tables are merged which results in a  subset of the standard SAP extractor 
2LIS_13_VDITM which is used in the iSynery Project.

## SQL-statements:
The following SQL-statements where used to extract the data via the Q30 
using a view on L30.  

Notes: 
1. some fields are empty but extracted just for clarity reasons.  

### VBRK
> SELECT VBELN, FKDAT, FKART, VKORG, VTWEG, BSTNK_VF, 
>        VBTYP, FKSTO, KURST, KURRF, WAERK, STWAE
>   FROM ZZ_L30_VBRK
>     WHERE MANDT = '902'      AND 
>           FKDAT > '20131231' AND
>           FKDAT < '20150630'

From:    `r min(dtVBRK$FKDAT)` 
To:      `r max(dtVBRK$FKDAT)`
Records: `r nrow(dtVBRK)`

### VBRP
> SELECT VBELN, POSNR, MATNR, WERKS, FKIMG, FKLMG, 
>        KZWI1, KZWI2, KZWI3, KZWI4, KZWI5, KZWI6, 
>        NETWR, MWSBP, WAVWR, 
>        SHKZG, VGPOS, VGBEL, FAREG, 
>        VRKME, MEINS, STCUR, FBUDA, ABRVW     
>   FROM ZZ_L30_VBRP
>     WHERE MANDT = '902'      AND 
>           FBUDA > '20131231' AND
>           FBUDA < '20150630'

From:    `r min(dtVBRP$FBUDA)` 
To:      `r max(dtVBRP$FBUDA)`
Records: `r nrow(dtVBRP)`

## Source Data 

```{r PrepareDataSet, echo=fECHO, eval=fEVAL, results=fRESULTS}

dtTMP04 <- dtVBRP[MATNR == " " ] # MATNR == "A9990002" |

fWriteToSheet(dtTMP04, 
             pPath, pXLSX, "Records_DEL", pAppend = TRUE)
dtVBRP <- dtVBRP[MATNR != " "] # MATNR != "A9990002" & 

system.time(dtDATA <- merge(dtVBRK, dtVBRP, by = "VBELN"))
setkey(dtDATA, "VBELN")

rm(dtVBRK, dtVBRP)
gc()

# remove leading zero's
dtDATA <- dtDATA[, MATNR:= gsub("(^|[^0-9])0+", "\\1", MATNR, perl = TRUE)]

```

Below the structure of the source data and the number of records is displayed

```{r displayDetailMean, echo=fECHO, eval=fEVAL, results='markup'}

str(dtDATA)
head(dtDATA[, c(1:7)             , with = FALSE])
head(dtDATA[, c(8:ncol(dtDATA))  , with = FALSE])

# fWriteToSheet(as.data.frame(str(dtDATA)), pPath, pXLSX, , "Structure", pAppend = TRUE)
fWriteToSheet(head(dtDATA[1:10]), 
              pPath, pXLSX, "Example_DATA", pAppend = TRUE)
```

```{r ChangeDataTypes, echo=fECHO, eval=fEVAL, results=fRESULTS}

# # Change data Types and set NA to 0
# system.time(
#   dtDATA <- dtDATA[, `:=`(
#     FKIMG     = ifelse(is.na(FKIMG), 0, as.integer(FKIMG)),
#     NETWR     = ifelse(is.na(NETWR), 0, as.numeric(sub(",", ".", NETWR))), 
#     MWSBP     = ifelse(is.na(MWSBP), 0, as.numeric(sub(",", ".", MWSBP))), 
#     WAVWR     = ifelse(is.na(WAVWR), 0, as.numeric(sub(",", ".", WAVWR))))])
# 
# gc()
```

```{r  Calculations, echo=fECHO, eval=fEVAL, results=fRESULTS}

# Create TransactionFlag Mapping Table
dtTRXFLG <- data.table(ABRVW          = c(" "   , "000" , "001" , 
                                          "105" , "107" , "108" , 
                                          "109" , "200"),
                       RETAILTYPECODE = c("Z103", "Z103", "Z105",
                                          "Z109", "Z110", "Z107",
                                          "Z108", "Z111"))

fWriteToSheet(dtTRXFLG, 
              pPath, pXLSX, "TRX_INITIAL_MAPPING", pAppend = TRUE)

# Transaction Flag - initial Mapping
dtDATA <- merge(dtDATA, 
                dtTRXFLG, 
                by = "ABRVW")

dtDATA <- dtDATA[SHKZG == "X" & ABRVW == "000",   RETAILTYPECODE:= "Z104"]
dtDATA <- dtDATA[SHKZG == "X" & ABRVW == "001",   RETAILTYPECODE:= "Z106"]

dtDATA <- dtDATA[, `:=`(
  VBELN          = paste0("H", substr(VBELN, 2, 10))   ,  # start with H to make distinction  
  RPA_TTC        = ifelse(SHKZG == "X", "Z312", "Z101"),
  RPA_DRC        =                                   NA,  # not available for VEUK
  G1LINKV        =                                   NA,  # GVBNL link Field not available for VEUK
  QUANTITY       = ifelse(SHKZG == "X", -FKIMG, FKIMG) ,
  ORGSCCOST      =                                    0,  # not maintained in VEUK system
  RETTRCOST      =                                    0,  # not maintained in VEUK system
  G1DISCIT       =                                    0,  # not maintained in VEUK system
  ABRVW          =                                 NULL,  # not needed anymore
  FBUDA          =                                 NULL   # not needed anymore 
  )]

rm(dtTRXFLG)
# table(paste0(dtDATA$ABRVW, dtDATA$SHKZG,dtDATA$RETAILTYPECODE))
```

### Data Source

```{r LegacyStoreToSAP, echo=FALSE, results=fRESULTS}
# add the iSynergy Store next to the legacy store
setnames(dtADRC, "ADDRNUMBER", "ADRNR")

dtWERKS  <- merge(dtT001W[ , .(ADRNR, WERKS, VKORG, VTWEG, VLFKZ)], 
                  dtADRC[  , .(ADRNR, SORT2)],
                  all.x = TRUE, by = "ADRNR")

# Select only UK stores
dtWERKS  <- dtWERKS[substr(VKORG, 1, 2) %in% c("GB", "IE")]

# Remove stores which are not Mapped
dtTMP01  <- dtWERKS[ is.na(SORT2)][, SORT2:= NULL]
fWriteToSheet(dtTMP01, 
              pPath, pXLSX, "WERKS_NO_SORT2", pAppend = TRUE )

dtWERKS  <- dtWERKS[!is.na(SORT2)] 

# Add Sales Org from list which include the closed Stores
dtSDP_01  <- copy(dtSDP_VE[, SORT2:= substr(WERKS, 2, 4)])
setnames(dtSDP_01, c("WERKS"), c("LWRKS"))
fWriteToSheet(dtSDP_01, 
              pPath, pXLSX, "LegacyStore_incl_Closed", pAppend = TRUE )

dtWERKS   <- merge(dtWERKS, 
                   dtSDP_01, 
                   all.y = TRUE, by = "SORT2" )
# dtORG     <- dtWERKS[, .N, by =.(VKORG, SALESORG)]

# stores With Sales
dtTMP03 <- dtWERKS[!(LWRKS %in% unique(dtDATA$WERKS))]
fWriteToSheet(dtTMP03, 
              pPath, pXLSX, "WERKS_WO_SLS", pAppend = TRUE )

dtWERKS <- dtWERKS[LWRKS %in% unique(dtDATA$WERKS)]

# Quality check on Duplicates
dtWERKS  <- dtWERKS[, DUP:= duplicated(dtWERKS, by = "SORT2")]

dtTMP02  <- copy(dtWERKS)
dtTMP02  <- dtTMP02[, DUP2:= any(DUP)         , by = "SORT2" ]
dtTMP02  <- dtTMP02[DUP2 == TRUE ]
fWriteToSheet(dtTMP02, 
              pPath, pXLSX, "WERKS_DUP", pAppend = TRUE )
fWriteToSheet(dtWERKS[DUP == TRUE], 
              pPath, pXLSX, "LWRKS_DEL", pAppend = TRUE )

dtWERKS  <- dtWERKS[DUP == FALSE][, DUP:=NULL]
dtWERKS  <- dtWERKS[, .(WERKS, LWRKS, SALESORG, DISTR_CHAN)]

# Add the iSynergy Site to the Data Set based upon Legacy site  
setnames(dtDATA, c("WERKS"), c("LWRKS"))

# Create List of Dummy stores which are not used
setnames(dtPLANT, c("/BIC/G1LGSTNO"), c("G1LGSTNO"))
l_DUMMIES_USED <- dtPLANT[substr(PLANT,1,1) == pLGCINDC, .(PLANT, G1LGSTNO)]
l_DUMMIES_LIST <- paste0(pLGCINDC, str_pad(1:1000, 3, pad ="0"))
l_DUMMIES_LIST <- setdiff(l_DUMMIES_LIST, l_DUMMIES_USED )

# Introduce dummy stores for closed stores which are not in iSYnergy
l_WERKS <- nrow(dtWERKS[is.na(WERKS)])
dtWERKS <- dtWERKS[, WERKS:= ifelse(is.na(WERKS),
                                    paste0(pLGCINDC, 
                                    str_pad(1:l_WERKS, 3, pad ="0")),
                                    WERKS)]
fWriteToSheet(dtWERKS, 
              pPath, pXLSX, "SITE_MAPPING", pAppend = TRUE )

# dtDATA  <- dtDATA[, SORT2:= substr(LWRKS, 2, 4) ] 
dtDATA  <- merge(dtWERKS, dtDATA, 
                 all.y = TRUE, by = "LWRKS")


```

## Store Mapping

Following Stores could not be mapped and are removed from the store Master Data:

```{r Non-Mapped_Stores, echo=fECHO, eval=fEVAL, results=fRESULTS}
dtTMP01
dtTMP02

rm(dtWERKS , dtPLANT , dtADRC , dtT001W, 
   dtTMP01 , dtTMP02 , dtTMP03, dtTMP04, 
   dtSDP_VE, dtSDP_01, l_DUMMIES_USED)
gc()
```

### Legacy & SAP Site

The legacy site in the hsitorical data is named LWRKS. 
The related SAP Site (WERKS) is joined based upon the last SORT2 field.
Note that the last 3 characters are used from teh legacy site as teh SORT2 field
doesnt have the J, V and I anymore.

Át the same time the iSynergy Sales organization and the distribution channel is
added to the transactional data. This can be used for connecting the Sales Organization 
specific article master data (0MAT_SALES coming from MVKE)


result: `r str(dtDATA)`

### Legacy & SAP Article

Next the related SAP article will be added to teh historical data if exisitng.
For this the mapping table MEAN is used from client 250 for EANTP = Z2. 
In case no SAp article exist the field will be empty. 

```{r LegacyArticleToSAP, echo=fECHO, eval=fEVAL, results=fRESULTS }
dtMATNR <- dtMEAN[MEINH == "ST" & 
                    EANTP == "Z2" &
                    EAN11 != "DUPLICATE", 
                  .(MATNR, EAN11, EANTP)]
setnames(dtMATNR, c("EAN11"), c("LMTNR"))

# Quality check on Duplicates
dtMATNR  <- dtMATNR[, DUP:= duplicated(dtMATNR, by = "LMTNR")]

dtTMP03  <- copy(dtMATNR)
dtTMP03  <- dtTMP03[, DUP:= any(DUP)          , by = "LMTNR" ]
dtTMP03  <- dtTMP03[DUP == TRUE ][, DUP:=NULL]
fWriteToSheet(dtTMP03, 
              pPath, pXLSX, "MEAN_DUP" , pAppend = TRUE )
fWriteToSheet(dtMATNR[DUP == TRUE], 
              pPath, pXLSX, "LMNTR_DEL", pAppend = TRUE )

dtMATNR  <- dtMATNR[DUP == FALSE][, DUP:=NULL]

# Add the iSynergy Article next to the legacy article
setnames(dtDATA, c("MATNR"), c("LMTNR"))

# All Articles With Sales 
dtMATNR <- merge(data.table(LMTNR = unique(dtDATA$LMTNR)),
                 dtMATNR,
                 by = "LMTNR", all.x= TRUE)

# Introduce dummy Articles for Articles which are not in iSYnergy
dtMATNR <- dtMATNR[, 
                   `:=` (EANTP = "Z2",
                         MATNR = ifelse(is.na(MATNR),
                                        paste0(pLGCINDC, 
                                               str_pad(1, 17, pad ="0")),
                                        MATNR))]

dtDATA <- merge(dtMATNR, 
                dtDATA, 
                by = "LMTNR", all.y = TRUE )

rm(dtMATNR, dtMEAN, dtTMP03)
gc()
```


final Result: `r str(dtDATA)`

## Create Export File

The resulting file is exported to .csv format using a , as list-separator.
The file wil lhave 1 header row with the names, The decimal separator will be .

```{r EXPORT, echo=fECHO, eval=fEVAL, results=fRESULTS}
# Get Datasource fields in the right order
dtDS         <- merge(dtRSDSSEGFD, 
                      dtRSDSSEGFDT[, .(POSIT, TXTLG )], 
                      by = "POSIT")
dtDS         <- dtDS[, POSIT:= as.numeric(
  sub(pattern = ",", replacement = ".", x = POSIT, fixed = TRUE))] 
setkey(dtDS, "POSIT")
dtDS         <- dtDS[, .(SYSTID , DATASOURCE, POSIT, 
                         FIELDNM, DATATYPE  , DECIMALS, IOBJNM, TXTLG)]
rm(dtRSDSSEGFD, dtRSDSSEGFDT)

setnames(dtDATA,
         c("FKDAT"         , "VBELN"     , "POSNR"     ,    
           "LWRKS"         , "WERKS"     , 
           "LMTNR"         , "MATNR"     , 
           "VRKME"         , "STWAE"     ,
           "NETWR"         , "MWSBP"     , "WAVWR"),
         c("SLSDATE"       , "BILL_NUM"  , "BILL_ITEM" ,  
           "G1LGSTNO"      , "PLANT"     , 
           "G1LGART"       , "MATERIAL"  , 
           "UNIT"          , "DOC_CURRCY",
           "NETVAL_INV"    , "TAX_AMOUNT", "RETPRCOST"
         ))

# # Select and Order the fields in the same order as the DataSource
dtDATA <- dtDATA[, dtDS$FIELDNM, with = FALSE]

# dtDATA <- dtDATA[,
#                  .(SLSDATE   , BILL_NUM, BILL_ITEM , RPA_TTC   ,
#                    G1LGSTNO  , PLANT	 , SALESORG  , DISTR_CHAN,
#                    G1LGART   , MATERIAL, RPA_DRC   , G1LINKV   ,	
#                    QUANTITY  , UNIT    , DOC_CURRCY, NETVAL_INV,
#                    TAX_AMOUNT, G1DISCIT, ORGSCCOST , RETPRCOST,
#                    RETTRCOST , RETAILTYPECODE)]

# ZFTP_FN_POS_HISTORY
# usr/sap/BA1/FTP/POS/HISTORY/POS_HISTORY.csv

if(pEXP){
  write.table(dtDATA, 
              file = file.path("c:", "FTP", pEXPORT),
              quote = TRUE     , sep = ",", na = "", dec = ".",             
              row.names = FALSE, col.names = TRUE, append = FALSE)
  }

write.table(dtDATA[1:pSMALL], 
            file = file.path("c:", "FTP", 
                             paste0("POS_HISTORY_small" , "_"      , 
                                    pECC_SYST, ".csv")) ,
            quote = TRUE     , sep = ","       , na = "", dec = ".",           
            row.names = FALSE, col.names = TRUE, append = FALSE)

fWriteToSheet(dtDATA[1:pSMALL], 
              pPath, pXLSX, "POS", pAppend = FALSE )
```

# Result

The structure below shows a part of the generated file

```{r displayResult, echo=fECHO, eval=fEVAL, results='markup'}
any(is.na(dtDATA$MATERIAL))
any(is.na(dtDATA$PLANT))

setdiff(names(dtDATA), dtDS$FIELDNM)
setdiff(dtDS$FIELDNM , names(dtDATA))
 
dtMonths

str(dtDATA)
head(dtDATA[, c(1:5)            , with = FALSE])
head(dtDATA[, c(6:10)           , with = FALSE])
head(dtDATA[, c(11:15)          , with = FALSE])
head(dtDATA[, c(16:20)          , with = FALSE])
head(dtDATA[, c(21:ncol(dtDATA)), with = FALSE])

rm(dtDS)
```
